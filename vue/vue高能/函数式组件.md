# 函数式组件

time: 2021-05-06 16:04:26  
author: heyunjiang

## 1 函数式组件基本知识

1. 组件所有的 attribute 都会被解析为 prop
2. 声明方式：template + functional，或者 functional: true
3. 使用 context 对象传递参数，包含了 props, children, slots, scopedSlots, data, parent, listeners, injections。其中，`context.data` 是所有 attribute 和事件的统一集合

## 2 问题

1. 为什么能提升系统性能？
2. 函数式子组件会受到影响吗？为什么？
3. 函数式组件是如何渲染的呢？

## 3 编译结果

函数式组件的 jsx 或 template 编译结果还是生成 render 方法，内部使用 createElement 代替了标签，而我们普通组件运行结果是有一个 vm 对象，该对象有众多属性和方法。那么函数式组件生成的是啥结果呢？
来看看 createComponent 方法  
```javascript
const baseCtor = context.$options._base
if (isObject(Ctor)) {
  // Vue.extend 表示合并新的配置，生成新的 Vue 对象，此刻未实例化
  Ctor = baseCtor.extend(Ctor)
}
if (isTrue(Ctor.options.functional)) {
  return createFunctionalComponent(Ctor, propsData, data, context, children)
}
const vnode = new VNode(
  `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
  data, undefined, undefined, undefined, context,
  { Ctor, propsData, listeners, tag, children },
  asyncFactory
)
return vnode
```

如果 functional === true，内部调用 createFunctionalComponent 来生成函数式组件  
```javascript
export function createFunctionalComponent () {
  // 1. 生成 render context 对象
  const renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  )
  // 2. 同样调用 render 生成 vnode 对象
  const vnode = options.render.call(null, renderContext._c, renderContext)
  if (vnode instanceof VNode) {
    // 3. 标记为函数式 vnode
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
  }
}
```

在调用 createElement 生成 vnode 之后，通过 vm._update 去渲染 vnode，来看看渲染对 functional 组件的处理  
处理流程如下: patch -> createElm -> createComponent，而 createComponent 内部调用 Vue.init 来初始化组件对象  
```javascript
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  let i = vnode.data
  if (isDef(i)) {
    const isReactivated = isDef(vnode.componentInstance) && i.keepAlive
    if (isDef(i = i.hook) && isDef(i = i.init)) {
      i(vnode, false /* hydrating */)
    }
  }
}
```


函数式组件和普通组件处理对比  
1. 函数式组件会生成 render context 对象，提供给 render 函数的第二个参数，同时作为 vnode 的 fnContext 属性值
2. 2类组件都会生成 vnode 实例
3. 普通组件会直接 new Vnode，而函数式组件会调用 render 方法去执行。为什么？函数式组件的编译结果为一个函数，普通组件编译结果为一个对象？

## 突发灵感

2021-05-06 19:32:48

vue 组件核心的是 createElement 生成 vnode，然后调用 patch 去渲染成真实 dom，而且这2块分别属于 `src/core/vdom/create-element` 和 `src/core/vdom/patch` 模块，再次归纳一下 vue2 的核心模块

1. `vdom` 下包含了 createElement 和 patch 2大核心，涉及到 vnode 的生成和渲染真实 dom
2. `observer` 模块实现了响应式系统，内部实现了 watcher, dep, scheduler 核心对象，也作为 vue 实例和 vdom 的衔接点
3. 衔接 vm、vdom：在 `src/core/instance/lifecycle/` 的 mountComponent 方法中，使用到了 watcher 对象。updateComponent 作为 watcher 的更新方法，又调用了 `vm._update(vm._render())` 结构
4. vm._render：直接调用 vm.render 方法，render 方法内部是使用的 vdom.createElement 方法，生成 vnode 对象
5. vm._update：调用 vdom.patch 来渲染 vnode 为真实 dom
6. `instance`: 生成 vm 实例，实现了 data、injections、provide 数据管理、自定义事件管理、lifecycle 渲染 dom、render 生成 vnode 模块；
其中 lifecycle 定义了 vm._update 渲染 dom，render 定义了 vm._render 生成 vnode 对象，这2个核心衔接模块，由 watcher 统一调度，包括初次渲染和后续更新

总结  
1. 整体来看，instance 作为核心对象，内部调用 watcher 来管理自身关键方法调用，自身关键方法调用了 vdom 的生成 vnode 和渲染真实 dom 的接口
2. 一个组件实例，包含了自身一系列属性和方法，包括 vnode、$el 对象

## 参考资料

[vue 函数式组件](https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6)
