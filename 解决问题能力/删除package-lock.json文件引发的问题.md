# 复杂问题解决能力：删除package-lock.json文件引发 vue slot 渲染问题

time: 2021-08-17 16:20:55  
author: heyunjiang

## 背景

我们为了保证公用的 npm 模块每次打包都是最新的，就把项目中的 package-lock.json 文件给删除了，并发布在灰度环境，看看有什么问题  
团队细心的小伙伴发现了公用组件的内容渲染出现了问题：本地跑是正常的，线上灰度就不正常

通用组件代码，灰度上 slot 后备内容无法渲染
```javascript
<div class="body">
  <div class="content">
    <slot name="content">
      <customer-component-a v-if="a" />
      <customer-component-b v-if="b" />
    </slot>
  </div>
</div>
```

## 1 问题分析

整体问题解决流程
1. 初步分析现象，判断是否曾经遇到过。没有遇到过，一眼看不出问题所在
2. 问题复现：沟通之后，通过对比自己本地和灰度，复现了这个问题
3. 调试通用组件：本地调试通用组件项目，通过插入特定字符串，发现内部具名 slot 的后备内容无法渲染，输出 undefined
4. 组件代码写法核验：仔细对比 vue 官方文档，发现我们写法没有任何问题
5. 问题猜测：既然我们写法没有问题，加上我们近期删除了 package-lock.json 文件，猜测问题是 vue 版本变更之后导致的具名 slot 后备内容问题
6. 对比 vue 版本：从 ci 下载以往打的包，查看 node_modules 内 vue 版本，发现和我们删除 package-lock 之后的本地有所不同，以往 lock 是 2.6.10，本地是 2.6.14
7. 验证猜测：固定本地 vue 和 vue-template-compiler 版本，查看问题是否修复。猜测正确
8. 更新灰度：固定版本之后发布更新灰度环境，问题得到解决

问题到这里虽然是解决了，但是心里又有了问题  
1. 为什么 vue 2.6.14 就会不渲染 slot 后备内容呢？
2. 为什么换成 vue 2.6.10 就会好了

## 2 测试 vue 2.6.14 构建是否有问题

使用 vue-cli 快速搭建 2.6.14 环境

```javascript
// Customer.vue
<div>Customer</div>

// HelloWorld.vue
<div class="hello">
  <slot>default content</slot>
  <slot name="footer"><Customer /></slot>
</div>

// App.vue
<HelloWorld>999</HelloWorld>
```

输出结果：  
```javascript
999
Customer
```

发现还是能正常渲染具名 slot 后备内容，所以不是 vue 版本问题，那为什么实际项目就会有问题？  
再次分析项目的构建方式，有如下发现  
1. 项目 build 时 vue 是作为 external 存在
2. vue 是通过 script 方式引入的固定版本 2.6.10

再次猜测是因为 vue 版本和 vue-template-compiler 版本不同导致 slot 后备内容渲染问题

## 3 vue 不同版本 slot 渲染

我们借用 vue-cli 来快速编译 vue 文件，控制好 vue 和 vue-tempalte-compiler 版本

第一步：固定 vue template 写法，还是使用上面的示例
```javascript
<template>
  <div class="hello">
    <slot>default content</slot>
    <slot name="footer"><Customer /></slot>
  </div>
</template>
```

第二部：查看 vue-template-compiler 不同版本编译结果  
构建 npm script: `vue-cli-service build --target lib ./src/components/HelloWorld.vue`  
```javascript
// 2.6.14
return _c('div',{staticClass:"hello"},[_vm._t("default",function(){return [_vm._v("default content")]}),_vm._t("footer",function(){return [_c('Customer')]})],2)
// 2.6.10
return _c('div',{staticClass:"hello"},[_vm._t("default",[_vm._v("default content")]),_vm._t("footer",[_c('Customer')])],2)
```

第三部：查看 vue 不同版本 _vm._t 是如何渲染 slot 内容的  
_t 表示 renderSlot，具体 slot 渲染流程可以查看 [插槽渲染](https://github.com/heyunjiang/Blog/blob/master/vue/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%8F%92%E6%A7%BD%E6%B8%B2%E6%9F%93.md)

```javascript
// 2.6.14
export function renderSlot (
  name: string,
  fallbackRender: ?((() => Array<VNode>) | Array<VNode>),
  props: ?Object,
  bindObject: ?Object
): ?Array<VNode> {
  const scopedSlotFn = this.$scopedSlots[name]
  let nodes
  if (scopedSlotFn) {
    props = props || {}
    if (bindObject) {
      props = extend(extend({}, bindObject), props)
    }
    nodes =
      scopedSlotFn(props) ||
      (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender)
  } else {
    nodes =
      this.$slots[name] ||
      (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender)
  }

  const target = props && props.slot
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}
// 2.6.10
export function renderSlot (
  name: string,
  fallback: ?Array<VNode>,
  props: ?Object,
  bindObject: ?Object
): ?Array<VNode> {
  const scopedSlotFn = this.$scopedSlots[name]
  let nodes
  if (scopedSlotFn) {
    props = props || {}
    if (bindObject) {
      props = extend(extend({}, bindObject), props)
    }
    nodes = scopedSlotFn(props) || fallback
  } else {
    nodes = this.$slots[name] || fallback
  }

  const target = props && props.slot
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}
```

代码分析  
1. 在我们没有使用具名插槽时，就会使用默认的 fallback 作为 nodes 渲染
2. 10 版本编译为 createElement 数组，14 版本编译为函数，通过函数返回 createElement 数组
3. renderSlot 返回的 nodes 节点作为子节点
4. 10 版本是直接返回的 fallback，14 版本是要执行 fallbackRender 函数

第四步-结论：将 14 版本编译的函数结果，让 10 版本的 renderSlot 执行，返回的 nodes 是函数，所以不会生成我们想要的 vdom 节点  
所以，vue 版本要和 vue-template-compiler 要保持一致，本期的问题就是版本不一致导致的 slot 后备内容渲染不出来

## 4 方法总结

本期解决问题的套路如下  
1. 肉眼分析问题，判断是否曾经遇到过
2. 问题复现
3. 定位问题，这里通过插入特定字符串缩小显示问题范围。通常可以通过 `插入特定字符串`、`console输出日志`、`debugger 加入断点`、`调用栈分析`、`删除代码缩小问题范围` 等方式定位问题
4. 结合变更场景具体分析问题，快速得到结论或者提出猜测
5. 本地修改，快速验证：通过 whistle 等工具将线上静态文件打到本地环境，验证修改是否能解决问题

问题的解决，需要对项目比较熟悉，包括构建工具、项目业务逻辑、组件架构、vue框架。如果短时间解决不了，就及时寻求帮助吧
